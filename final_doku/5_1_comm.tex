%\section{Design Alternatives}\label{sec:alt}

\subsection{NFC Communication}\label{sec:comm}
\todo{alternativen rauÃŸ? Verwendetes Protokoll muss aber drin bleiben. Na logo!}
NFC devices are typically specified for a maximum range of $10cm$. Therefore, other solutions incorporating NFC assume that the physically constrained range is enough to prevent attackers to tamper with the transmitted data.
As basic NFC hardware is quite cheap, this is probably not the right approach for the future.

A fundamental part of our \app entrance access solution is the secured NFC communication between a mobile device and a terminal installed at a gate.
This section presents building blocks ranging from low-level to high-level aspects of the NFC communication in order to achieve this goal.


\subsubsection{Hardware Setup}
Exchanging data needs a communication link between an Android smartphone and a NFC reader.
To make it work, the NFC reader must support common NFC standards (e.g., ISO/IEC 14443) and provide stable transmission properties.
Therefore, we examine our utilized hardware setup:
%
\begin{itemize}
	\item Raspberry Pi with a PN532 compliant NFC cape, e.g., \textit{ITEAD PN532 NFC module}.
	\item Android mobile device with NFC capabilities and Android 4.4 or newer.
\end{itemize}
%
Using the Raspberry Pi as underlying platform and the proposed NFC transceiver, a cheap and powerful setup is possible.
Providing a rich interface to interact with the environment, it allows an easy integration into existing door electronics.
For communication, the free NFC library \textit{libnfc}\footnote{\url{http://nfc-tools.org/}} abstracts low-level functionality to provide a data link-layer. 
%However, the protocol layer is often incomplete and needs tweaks. This might influence the stability in the communication link.

On the other side, a smartphone with NFC transceiver and Android 4.4 (or higher versions) offers all required APIs in a simple way to exchange data between two Android smartphones over NFC.
Additionally, integrated capabilities like Wifi or Bluetooth allow enhanced applications. The downsides of this approach are much higher costs, missing interfaces to interact directly with most door electronics and required user interaction for certain tasks (e.g.~OS upgrade).



\subsubsection{Protocols for Authentication between Smartphone and NFC Reader}\label{sec:alt:proto}
A critical aspect in our project is the communication between a smartphone $ S $ and the NFC component $ T $.
It is important that it is safe so that no unauthorized party can easily gain access or eavesdrop sensitive information like the student ID.
By placing the reader's antenna in the inner side of the door, it should be safe from physical threats from outside.
To ensure a secure communication on top of the data carrier, we plan to use one of the protocols introduced in this section.
Which one to finally choose depends on multiple aspects like the capabilities of the NFC hardware (e.g.~processing power), Android support or fault tolerance. This needs some testing done during the project. 

\subsubsection{Protocol with Public-Key Cryptography}\label{sec:alt:proto:pubkey}
The first proposed protocol uses a Public Key Infrastructure to establish secure communication links between the participants.
For authentication on both sides and mitigation of several attack scenarios, it uses some ideas of the Needham-Schroeder-Lowe Public Key protocol. Lowe contributes an important security fix we use.
The scheme is enhanced to provide further security features specific for the utilised backend and the scenario.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Redefine the \mess due to problems with math support $ \some_function $ %
% See: http://tex.stackexchange.com/questions/164707/how-to-use-greek-    %
%      letters-in-pgf-umlsd-or-generally-terms-starting-with              %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\renewcommand{\mess}[4][0]{
  \stepcounter{seqlevel}
  \path
  (#2)+(0,-\theseqlevel*\unitfactor-0.7*\unitfactor) node (mess from) {};
  \addtocounter{seqlevel}{#1}
  \path
  (#4)+(0,-\theseqlevel*\unitfactor-0.7*\unitfactor) node (mess to) {};
  \draw[->,>=angle 60] (mess from) -- (mess to) node[midway, above]
  {#3};
}
%
\begin{sequencediagram}
	\newinst{S}{Smartphone $ S $}
	\newinst[9]{T}{NFC Reader $ T $}
	% \newinst[4]{rnc}{RNC}
	\mess{S}{1. $ {\{r_S, pseudoStudentID\}}_{K_{T-pub}} $}{T}
	\postlevel
	\mess{T}{2. $ {\{r_S, r_T\}}_{K_{S-pub}} $}{S}
	\postlevel
	\mess{S}{3. $ {\{r_T, H(salt|studentToken), commands\}}_{K_{T-pub}} $}{T}
	%\mess{nodeb}{Synchronization Indication}{rnc}
	%\filldraw[fill=black!30] ($(RRC Connection Setup to)+(0,-.3)$) rectangle ($(Synchronization Indication from) +(0,.3)$)
	%node[midway] {L1 Synchronization};
\end{sequencediagram}
%
Explanation:
%
\begin{enumerate}
	% 1.
	\item $ S \rightarrow R $:
	\begin{itemize}
		\item $ S $ generates a random number $ r_S $ and sends it to $ T $ together with the $ pseudoStudentID $, encrypted with the reader's public key $ K_{T-pub} $.
		\item The official student ID is replaced by the pseudonym $ pseudoStudentID $, which is associated with the official ID of the student in the backend.
		Like this, a MITM attack would not allow to directly gain information about the requesting person's ID.
		Furthermore, this pseudonym association can be changed regularly.
	\end{itemize}	
	% 2.
	\item $ S \leftarrow R $:
	\begin{itemize}
		\item The reader $ T $ looks up the public key $ K_{S-pub} $ based on the pseudo student ID. If it doesn't exist, further communication stops here.
		\item On success, $ T $ generates a random number $ r_T $ and sends it back to $ S $ together with $ r_S $ and a hash of its own public key, encrypted with the user's public key $ K_{S-pub} $.
%		\item Providing the identity $ T $, the requesting party can verify whether the reader's public key changed. This could originate from an attack in step 1 (e.g., fake reader). In that case, abort further communication to assure confidentiality.
	\end{itemize}	
	% 3.
	\item $ S \rightarrow R $:
	\begin{itemize}
		\item If $ S $ receives a valid answer in step 2, it should be fine to proceed.
		\item $ S $ sends $ r_T $, a salted SHA-256 hash of $ studentToken $ and data to $ T $, encrypted with $ K_{T-pub} $.
		\item Salted SHA-256 student token $ H(salt|studentToken) $: as the random salt is unique per user and only known to the back-end and the Android client, the terminal does not touch critical data.
		Still, by comparing the hash values received by the back-end on retrieval of the user's public key, and the one sent by the smartphone in this step, the identity of the user is proven indirectly.
	\end{itemize}
\end{enumerate}